//第十节课的操作步骤
root       5223   0 ps - eo ruser, pid, psr, args
[root@luckily day06]# vim 02
[root@luckily day06]# vim 02.c
[root@luckily day06]# cd ..
[root@luckily study]# cd day05
[root@luckily day05]# ls
02.c  03.c  04.c  05.c  06.c  07.c  08.c  8Linux051001.c  a.out  env.c
[root@luckily day05]# vim 08.c
[root@luckily day05]# cat 08.c
#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>

jmp_buf buf;

void fun(int n) {
	printf("in fun()\n");
	if (n == 1) {
		longjmp(buf, 1);
	}
	if (n == 2) {
		longjmp(buf, 2);
	}

	printf("ok\n");
}


int main(void) {
	int r;
	if ((r = setjmp(buf)) == 0) {
		fun(3);
		printf("normal\n");
	}
	else if (r == 1) {
		printf("catch 1 error\n");
	}
	else if (r == 2) {
		printf("catch 2 error\n");
	}
	printf("exit\n");
}
[root@luckily day05]# d ..
bash: d: 未找到命令...
[root@luckily day05]# cd ..
[root@luckily study]# cd day06
[root@luckily day06]# vim 03.c
[root@luckily day06]# vim 04.c
[root@luckily day06]# gcc - g 04.c
[root@luckily day06]# . / a.out
段错误(吐核)
[root@luckily day06]# ulimit - c unlimited
[root@luckily day06]# ls
01.c  02  02.c  03.c  04.c  a.out
[root@luckily day06]# gcc - g 04.c
[root@luckily day06]# . / a.out
段错误(吐核)
[root@luckily day06]# ls
01.c  02  02.c  03.c  04.c  a.out  core.6428
[root@luckily day06]# file core.6428
core.6428: ELF 64 - bit LSB core file x86 - 64, version 1 (SYSV), SVR4 - style, from './a.out', real uid : 0, effective uid : 0, real gid : 0, effective gid : 0, execfn : './a.out', platform : 'x86_64'
[root@luckily day06]# gdb a.out core.6428
GNU gdb(GDB) Red Hat Enterprise Linux 7.6.1 - 115.el7
Copyright(C) 2013 Free Software Foundation, Inc.
License GPLv3 + : GNU GPL version 3 or later < http ://gnu.org/licenses/gpl.html>
	This is free software : you are free to changeand redistribute it.
	There is NO WARRANTY, to the extent permitted by law.Type "show copying"
	and "show warranty" for details.
	This GDB was configured as "x86_64-redhat-linux-gnu".
	For bug reporting instructions, please see :
< http ://www.gnu.org/software/gdb/bugs/>...
	Reading symbols from / root / study / day06 / a.out...done.
	[New LWP 6428]
Core was generated by `. / a.out'.
Program terminated with signal 11, Segmentation fault.
#0  0x00007fa90b42c029 in vfprintf() from / lib64 / libc.so.6
Missing separate debuginfos, use: debuginfo - install glibc - 2.17 - 292.el7.x86_64
(gdb) q
[root@luckily day06]# vim 04.c
[root@luckily day06]# vim 04.c
[root@luckily day06]# gcc 04.c
04.c:5 : 21 : 致命错误：striing.h：没有那个文件或目录
#include <striing.h>
^
编译中断。
[root@luckily day06]# vim 04.c
[root@luckily day06]# gcc 04.c
[root@luckily day06]# . / a.out
close() :Bad file descriptor
[root@luckily day06]# vim 04.c
[root@luckily day06]# gcc 04.c
[root@luckily day06]# . / a.out
[04.c][11]close() :Bad file descriptor
[root@luckily day06]# vim 04.c
[root@luckily day06]# gcc 04.c
[root@luckily day06]# . / a.out
[root@luckily day06]# . / a.out
[root@luckily day06]# vim 04.c
[root@luckily day06]# gcc 04.c
[root@luckily day06]# . / a.out
[04.c][17]close:Bad file descriptor
[root@luckily day06]# vim 04.c
[root@luckily day06]# vim 05.c
[root@luckily day06]# gcc 05.c
05.c: 在函数‘main’中:
05.c : 25 : 6 : 错误：‘pif’未声明(在此函数内第一次使用)
if ((pif = fork()) == -1) ERR_EXIT("fork");
^
05.c:25 : 6 : 附注：每个未声明的标识符在其出现的函数内只报告一次
[root@luckily day06]# vim 05.c
[root@luckily day06]# gcc 05.c
/ tmp / cc4qP6EJ.o：在函数‘main’中：
05.c:(.text + 0x8a)：对‘eixt’未定义的引用
collect2 : 错误：ld 返回 1
[root@luckily day06]# vim 05.c
[root@luckily day06]# gcc 05.c
[root@luckily day06]# . / a.out
child pid = 7440
ret = 7440
............ ^ C
[root@luckily day06]# vim 05.c
[root@luckily day06]# cat 05.c
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define ERR_EXIT(msg)\
        do{\
         printf("[%s][%d]%s:%s\n",__FILE__,__LINE__,msg,strerror(errno));\
         exit(EXIT_FAILURE);\
        }while(0)


/*
	//功能：回收僵尸子进程
	pid_t wait(int* status);
	//返回值，被回收的子进程pid，-1，出错
	//atatus : 获得子进程的死亡信息

*/

int main(void) {
	pid_t pid;

	if ((pid = fork()) == -1) ERR_EXIT("fork");

	if (pid == 0) {
		printf("child pid = %d \n", getpid());
		getchar();
		exit(12);
	}
	else {
		pid_t ret;
		int status;
		if ((ret = wait(&status)) == -1) ERR_EXIT("wait");
		if (WIFEXITED(status)) {//子进程正常退出，WIFEXITED返回真
			printf("noraml exit: %d\n", WEXITSTATUS(status));
		}
		else if (WIFSIGNALED(status)) {
			printf("killed by kill cmd\n");
		}
		printf("ret = %d \n", ret);
		while (1) {
			printf(".");
			fflush(stdout);
			sleep(1);
		}
	}
}
[root@luckily day06]# vim 06.c
[root@luckily day06]# gcc 06.c
[root@luckily day06]# . / a.out
child pid = 7844
[06.c][35]wait:Bad address
[root@luckily day06]# vim 06.c
[root@luckily day06]# gcc 06.c
[root@luckily day06]# . / a.out
child pid = 7879
noraml exit : 12
ret = 7879
......... ^ ^C
[root@luckily day06]# vim 06.c
[root@luckily day06]# 
